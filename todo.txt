Todo:
    Implement latency walls. Define what they mean first.

    Binance.java
        Fix using MARGIN_BUY when enough funds is in our account (Binance won't borrow then). Refer to changelog
        Replace linear orderbook model with a square root market impact (later)
        Check and complete Binance code for non-automatic borrowings (later)
            Implement order triggers on self-made slippage (later)

    LocalStrategy.java
        Map action responses with action request types so when we receive a response we know which action we sent.
        Interest calculation based on position, except when using automatic repay on cancel, and we cancel the position.
        Local position closing, filling, profit calculation, etc...
        Handling all responses

    Order.java
        Change order IDs to use unique IDs instead of incremental numbers to simulate the fucked up nature of random IDs. (later)

Done:
    Next day now loads on the last transaction of the day
    Edited TransactionLoader to process relative transaction values, lowering sizes of files by 33%
    Implemented Events. Instead of iterating over transactions each event (action, request, transaction, and user data stream) is added to a queue and executed at the time of the event + the time it took to reach its destination (latency).
    Edited binance transaction latency testing to output all transactions to a file with a 'wall' flag - running on AWS Tokyo EC2 - results gathered
    Matched Order and Position arguments (seems so)
    Converted Candle to record
    Edited CandleConstructor to handle record Candle (test profusely.)